## 作用域和执行上下文

### **作用域**

JavaScript中的作用域中词法作用域,即由**函数声明时**所在的位置决定的.词法作用域是指在编译阶段就产生的,一整套函数标识符的访问规则.(区别于词法作用域,动态作用域是在函数执行的时候确认的,JavaScript没有动态作用域,但JavaScript的`this`很像动态作用域.)说到底JavaScript的作用域只是一个'空地盘',其中并没有真实的变量,但却定义了变量如何访问的规则.

作用域本质上是一个指向变量对象的指针列表,它只引用不包含实际变量对象,是作用域概念的延伸.作用域链定义了变量在当前上下文访问不到的时候如何没用域链继续查询的一套规则.

---

### **执行上下文**

执行上下文是指**函数调用时**产生的变量对象,这个变量对象我们无法直接访问,但是可以访问其中的变量,`this`对象等.

```
let fn,bar  //1.进入全局上下文玩着
bar = function(x){
  let b = 5
  fn(x + b) //3.进入fn函数上下文环境
}

fn = function(y){
  let c = 5
  console.log(y + c)  //4.fn出栈,bar出栈
}

bar(10) //2.进入把人函数上下文环境
```
![](./WX20190622-130748.png)

每次函数调用时,都会产生一个新的执行上下文的环境,JavaScript引擎会以栈的方式来处理它们,这个栈,我们称其为函数调用栈(call back).栈永远都是全局上下文,而栈顶就是当前处理活动状态的正在执行的上下文,,也称半自动对象(图中蓝色的块),区别与底下被挂起的上下文(变量对象)

总结:作用域是在函数声明的时候确定的一套变量访问的规则,而执行上下文是函数执行时才产生的一系列变量和环境.也就是说作用域定义了执行上下文中的变量的访问规则,执行一下文在这个作用域规则的前提下进行变量查找,函数引用等具体操作

---

### **理解函数执行过程**

函数的执行过程分成两部分,一部分用来生成执行上下文环境,确定this指向,声明变量以及生成作用域链;另一部分作用是按顺逐行执行代码

- 建立在执行上下文阶段(发生在:函数调用时 && 函数体内的代码执行前)  
  1. 生成变量对象,顺序 arguments 对象 --> 创建function函数声明 --> 创建var变量声明
  2. 生成作用或链
  3. 确定this的指向

- 函数执行阶段  
  4. 逐行执行代码,这个阶段会完成变量赋值,函数引用,以及执行其他代码.

### **this指向**

---

关于JavaScript的`this`关键字,说来说去只其实只有四种:
```
let fn = function(){
  alert(this.name)
}
let obj = {
  name:'',
  fn
}

fn()  //方法1
obj.fn()  //方法2
fn.call(obj)  //方法3
let instance = new fn() //方法4
```  

1. 方法1中直接调用函数fn(),这种看着像光杆司令的调用方法,this指向window(严格模式下是`undefined`)

2. 方法2中是点调用`obj.fn()`,此时`this`指向`obj`对象.点调用中`this`指的是点前面的对象

3. 方法3中利用`call`函数把`fn`中的`this`指向了第一个参数,这里是obj.即利用`call`,`apply`,`bind`函数可以把函数的`this`变量指向第一个参数

4. 方法4中用`new`实例化了一个对象`instance`,这里`fn`中的`this`就指向了实例`instance`

如果同时发生了多个规则该怎么办?世态炎凉上面四条规则的优先级是递增的

> `fn() < obj.fn < fn.call() < new fn()`

首先,`new`调用的优先级最高,只要有`new`关键字,`this`就指向实例本身;接下来如果没有`new`关键字,有`call`,`apply`,`bind`函数,那么`this`就是指向第一个参数;然后如果没有`new`,`call`,`apply`,`bind`,只有`obj.fn()`这种点调用方式,`this`指向点前面的对象;最后是光杆司令`fn()`这种调用方式,`this`指向`window`(严格模式下是`indefined`)

ES6中新增了箭头函数,而箭头函数最大的特色就是没有自己的`this`,`arguments`,`super`,`new.target`,并且箭头函数没有原型对象`prototype`不能用伯构造函数(`new`一个箭头函数会报错).因为没有自己的`this`,所以箭头函数中的`this`其实指的是包含函数中的`this`.无论是点调用,还是`call`调用,都无法改变税前函数中的`this`

---

### **闭包**

JavaScript闭包在MDN上的解释:  
> 闭包是函数和声明该函数的词法环境的组件  

在<你不知道的JavaScript>上册中关于闭包的定义比较清晰
> 当函数能够记住并访问所在的词法作用域于,就产生了闭包

```
let single = (function(){
  let count = 0
  return {
    plus(){
      count++
      return count
    },
    minus(){
      count--
      return count
    }
  }
})

single.plus()   //1
single.minus()  //0
```
这最个单例模式,这个模式返回一个对象`single`,对象中包含两个函数`plus`和`minus`,而这两个函数都用到了所在词法作用域中的变量`count`,所以在函数执行结束时`count`所在的执行环境不会被销毁,这就产生了闭包.每次调用`single.plus()`或者`single.minus()`,就会对闭包中的`count`变量进行修改,这两个函数保持住了对所在的词法作用域的引用.

闭包其实是一种特殊的函数,它可以访问函数内部的变量,还可以让这些变量的值始终保持在内在中,不会在函数调用后被垃圾回收机制清除

看个经典安案例;
```
// 方法1
for(var i=0;i<=5;i++){
  setTimeout(() => {
    console.log(i)
  },1000)
}

// 方法2
for(let i=0;i<=5;i++){
  setTimeout(() => {
    console.log(i)
  },1000)
}
```

方法1中,循环设置了5个定时器,一秒后定时器中回调函数将执行,打印变量`i`的值,毋庸置疑,一秒之后`i`已经递增到了5,所以定时器会打印6次(从0开始累加的). 
> 定时器中并没有找到当前作用域的变量`i`,所以没用作用域链找到了全局使用域中的`i`

方法2中,由于ES6的`let`会创建局部作用域,所以循环设置了5个作用域,每上作用域又设置了一个定时器,打印一秒后变量`i`的值.一秒后定时器从各自的父作用域中分别找到的变量`i`是0-5.这是个利用闭包解决循环中变量发生异常的方法.